<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Oil Spill Trajectory Model</title>

<!-- Tailwind (UI) -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- Turf (for point-in-polygon land tests) -->
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<style>
  body{background:#071225;color:#e6eef8;font-family:Inter,system-ui,Arial;margin:0;padding:18px}
  .card{background:#071426;border:1px solid #122033;border-radius:10px;padding:14px}
  .small{font-size:13px;color:#9fb0d6}
  .leaflet-container{height:60vh;border-radius:8px;border:1px solid #0e2533}
  .field-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .input-row{display:flex;flex-direction:column}
  .muted{color:#9fb0d6;font-size:12px}
  pre.math{background:#041427;padding:10px;border-radius:6px;color:#cfe8ff;overflow:auto}
  table { width:100%; border-collapse: collapse }
  table td, table th { padding:6px; border-bottom:1px solid rgba(255,255,255,0.04); font-size:13px }
</style>
</head>
<body>
  <div class="max-w-7xl mx-auto space-y-6">
    <header class="text-center">
      <h1 class="text-2xl font-bold">Oil Spill Trajectory Model</h1>
      <!-- <p class="small mt-1">Model: drift = current + windage·wind + diffusion. Stops when trajectory hits land (turf). This fixed version removes Gemini, fixes coordinate parsing, validates coords, and shows each spill separately.</p> -->
    </header>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <!-- Controls -->
      <aside class="card lg:col-span-1 space-y-3">
        <label class="small mt-2"><strong>Article text or <code>lat, lon</code> pairs</strong></label>
        <textarea id="article-input" rows="7" class="w-full p-2 rounded bg-[#041426] border border-[#123040]" placeholder="Paste article text here (or include coordinates like 12.02123, 92.98012). Multiple pairs allowed."></textarea>

        <label class="small mt-2"><strong>Environmental inputs (labeled)</strong></label>
        <div class="field-grid">
          <div class="input-row">
            <label><strong>Wind speed</strong> <span class="muted">(m/s)</span></label>
            <input id="wind-speed" type="number" step="0.1" value="7.0" class="p-2 rounded bg-[#041426] border border-[#123040]">
          </div>
          <div class="input-row">
            <label><strong>Wind direction</strong> <span class="muted">(° from - meteorological)</span></label>
            <input id="wind-dir" type="number" step="1" value="225" class="p-2 rounded bg-[#041426] border border-[#123040]">
          </div>
          <div class="input-row">
            <label><strong>Current speed</strong> <span class="muted">(m/s)</span></label>
            <input id="current-speed" type="number" step="0.1" value="0.5" class="p-2 rounded bg-[#041426] border border-[#123040]">
          </div>
          <div class="input-row">
            <label><strong>Current direction</strong> <span class="muted">(° to - flow direction)</span></label>
            <input id="current-dir" type="number" step="1" value="225" class="p-2 rounded bg-[#041426] border border-[#123040]">
          </div>
          <div class="input-row">
            <label><strong>Windage</strong> <span class="muted">(fraction)</span></label>
            <input id="windage" type="number" step="0.01" value="0.03" class="p-2 rounded bg-[#041426] border border-[#123040]">
          </div>
          <div class="input-row">
            <label><strong>Diffusion</strong> <span class="muted">(m²/s)</span></label>
            <input id="diffusion" type="number" step="0.1" value="2.0" class="p-2 rounded bg-[#041426] border border-[#123040]">
          </div>
        </div>

        <div class="flex gap-2 mt-3">
          <button id="analyze-btn" class="flex-1 py-2 rounded bg-blue-600 hover:bg-blue-700">Analyze & Project</button>
          <button id="sample-btn" class="py-2 px-3 rounded bg-gray-800 border border-gray-700">Sample</button>
        </div>

        <div id="status" class="small mt-2">Status: waiting</div>
        <div class="small mt-2">Tip: paste explicit <code>lat, lon</code> pairs (one or many) anywhere in the text. E.g. <code>12.0215, 92.9803</code> or <code>(11.5300, 92.6200)</code>.</div>
      </aside>

      <!-- Map + outputs -->
      <main class="card lg:col-span-2">
        <div id="map" class="leaflet-container"></div>

        <div class="mt-3 grid grid-cols-1 md:grid-cols-3 gap-3">
          <div class="p-2">
            <h3 class="font-semibold">Math readout</h3>
            <pre id="math-readout" class="math">No run yet.</pre>
          </div>
          <div class="p-2">
            <h3 class="font-semibold">Reef Hit Summary</h3>
            <div id="reef-summary" class="small mt-2">No run yet.</div>
          </div>
          <div class="p-2">
            <h3 class="font-semibold">Spill Details</h3>
            <div id="spill-summary" class="small mt-2">No run yet.</div>
          </div>
        </div>
      </main>
    </div>
  </div>

<script>
/* ---------------- REEF BBOXES ---------------- */
const REEF_BBOXES = {
  Havelock_Island: { lat_min:11.90, lat_max:12.05, lon_min:92.90, lon_max:93.05 },
  MG_Marine_NP:    { lat_min:11.50, lat_max:11.65, lon_min:92.55, lon_max:92.70 },
  Jolly_Buoy:      { lat_min:11.47, lat_max:11.52, lon_min:92.58, lon_max:92.64 },
  Neil_Island:     { lat_min:11.77, lat_max:11.88, lon_min:92.99, lon_max:93.10 }
};

/* ---------------- MAP ---------------- */
const map = L.map('map').setView([11.95, 92.95], 8);
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',{maxZoom:19}).addTo(map);
const reefLayer = L.layerGroup().addTo(map);
Object.entries(REEF_BBOXES).forEach(([k,bb])=>{
  const rect = L.rectangle([[bb.lat_min,bb.lon_min],[bb.lat_max,bb.lon_max]], { color:'#0ea5a4', weight:1, fillOpacity:0.06 }).addTo(reefLayer);
  rect.bindPopup(`<strong>${k.replace(/_/g,' ')}</strong>`);
});

let markers = [], trajectories = [];
function clearOverlays(){ markers.forEach(m=>map.removeLayer(m)); markers=[]; trajectories.forEach(t=>map.removeLayer(t)); trajectories=[]; }
function setStatus(msg, isErr=false){ const el=document.getElementById('status'); el.textContent='Status: '+msg; el.style.color = isErr ? '#fca5a5' : '#c7d2fe'; }

/* ---------------- Math helpers ---------------- */
function haversine_m(lat1, lon1, lat2, lon2){
  const R=6371000.0, toRad=Math.PI/180;
  const p1=lat1*toRad, p2=lat2*toRad; const dp=(lat2-lat1)*toRad, dl=(lon2-lon1)*toRad;
  const a=Math.sin(dp/2)**2 + Math.cos(p1)*Math.cos(p2)*Math.sin(dl/2)**2;
  return 2*R*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}
function windFromToUV(speed_mps, windFromDeg){ const windToDeg = (windFromDeg + 180) % 360; const th = windToDeg * Math.PI / 180; return { u: speed_mps * Math.sin(th), v: speed_mps * Math.cos(th) }; }
function dirToUV(speed_mps, dirToDeg){ const th = dirToDeg * Math.PI / 180; return { u: speed_mps * Math.sin(th), v: speed_mps * Math.cos(th) }; }
function randn(){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v); }

/* Improved coordinate extraction: supports integers, decimals, parentheses, semicolons, new lines */
function extractCoordsFromText(text){
  const out = [];
  if(!text || !text.trim()) return out;
  // look for latitude, longitude pairs in many common formats
  const rg = /(-?\d+(?:\.\d+)?)\s*[,;\s]\s*(-?\d+(?:\.\d+)?)/g;
  let m;
  while((m = rg.exec(text)) !== null){
    const a = Number(m[1]), b = Number(m[2]);
    // decide which is lat and lon: if both are in plausible ranges use (lat,lon) ordering
    if(Math.abs(a) <= 90 && Math.abs(b) <= 180){
      out.push({ lat: a, lon: b, source: 'regex' });
    } else if(Math.abs(b) <= 90 && Math.abs(a) <= 180){
      // reversed order in text: lon, lat -> swap
      out.push({ lat: b, lon: a, source: 'regex' });
    } else {
      // skip obviously invalid pairs
      continue;
    }
  }
  // deduplicate (within 1e-5 degrees)
  const uniq = [];
  out.forEach(o=>{
    const found = uniq.some(u => Math.abs(u.lat - o.lat) < 1e-5 && Math.abs(u.lon - o.lon) < 1e-5);
    if(!found) uniq.push(o);
  });
  return uniq;
}

/* Simple turf land test (requires coastline GeoJSON to be provided as COASTLINE_GEOJSON) */
async function isPointOnLand(lat, lon){
  if(typeof COASTLINE_GEOJSON !== 'undefined' && COASTLINE_GEOJSON && COASTLINE_GEOJSON.type === 'FeatureCollection'){
    try{ return turf.booleanPointInPolygon(turf.point([lon, lat]), COASTLINE_GEOJSON); }catch(e){ console.warn('turf error', e); }
  }
  // If no coastline supplied, be conservative and treat only very near-coast points as land using a simple bounding test around reefs
  // (This avoids slow reverse-geocoding in this fixed demo.)
  for(const bb of Object.values(REEF_BBOXES)){
    if(lat >= bb.lat_min - 0.05 && lat <= bb.lat_max + 0.05 && lon >= bb.lon_min - 0.05 && lon <= bb.lon_max + 0.05) return true;
  }
  return false; // assume water otherwise
}

/* Projection (Euler-Maruyama). Returns full path (no async inside) */
function projectDriftAdvanced(lat0, lon0, opts={}){
  const hours = opts.hours ?? 96;
  const dtHours = opts.dtHours ?? 1;
  const dtSec = dtHours * 3600;
  const steps = Math.max(1, Math.round(hours / dtHours));
  const windSpeed = opts.windSpeed ?? 7.0;
  const windFromDeg = opts.windFromDeg ?? 225;
  const currentSpeed = opts.currentSpeed ?? 0.4;
  const currentToDeg = opts.currentToDeg ?? 225;
  const windage = Math.max(0, Number(opts.windage) || 0.03);
  const diffusion = Math.max(0, Number(opts.diffusion) || 2.0);

  const windUV = windFromToUV(windSpeed, windFromDeg);
  const curUV  = dirToUV(currentSpeed, currentToDeg);
  const advU = curUV.u + windage * windUV.u;
  const advV = curUV.v + windage * windUV.v;
  const latPerMeter = 1.0 / 111320.0;
  const diffusionStd = Math.sqrt(2.0 * Math.max(0, diffusion) * dtSec);

  const path = [[lat0, lon0]];
  let lat = lat0, lon = lon0;
  for (let s = 0; s < steps; s++){
    const dx = advU * dtSec;
    const dy = advV * dtSec;
    const rx = randn() * diffusionStd;
    const ry = randn() * diffusionStd;
    const totalDx = dx + rx;
    const totalDy = dy + ry;
    const lonPerMeter = 1.0 / (111320.0 * Math.cos(lat * Math.PI / 180));
    lat += totalDy * latPerMeter;
    lon += totalDx * lonPerMeter;
    path.push([lat, lon]);
  }

  return { path, paramsUsed: { hours, dtHours, windSpeed, windFromDeg, currentSpeed, currentToDeg, windage, diffusion, advU, advV, diffusionStd } };
}

/* Analyze path against reefs (synchronous) */
function analyzePathAgainstReefs(pathPoints, reefs, dtHours=1){
  const results = {}; const start = pathPoints[0] || [null, null];
  Object.entries(reefs).forEach(([k,bb]) => results[k] = { willHit:false, etaHours:null, distanceKm:null });
  for(let i=0;i<pathPoints.length;i++){
    const [lat, lon] = pathPoints[i];
    Object.entries(reefs).forEach(([k,bb])=>{
      if(!results[k].willHit){
        if(lat >= bb.lat_min && lat <= bb.lat_max && lon >= bb.lon_min && lon <= bb.lon_max){
          results[k].willHit = true;
          results[k].etaHours = i * dtHours;
        }
      }
    });
  }
  Object.entries(reefs).forEach(([k,bb])=>{
    const centerLat = (bb.lat_min+bb.lat_max)/2, centerLon = (bb.lon_min+bb.lon_max)/2;
    const dkm = (start[0] === null) ? null : haversine_m(start[0], start[1], centerLat, centerLon) / 1000.0;
    results[k].distanceKm = dkm === null ? null : Number(dkm.toFixed(2));
  });
  return results;
}

/* Project but stop when land encountered (uses the synchronous projection then checks points) */
async function projectStoppingAtLand(lat0, lon0, modelOptions){
  const { path, paramsUsed } = projectDriftAdvanced(lat0, lon0, modelOptions);
  const safe = [];
  let hitLand = false, landPoint = null, landIndex = -1;
  for(let i=0;i<path.length;i++){
    const [lat, lon] = path[i];
    const onLand = await isPointOnLand(lat, lon);
    if(onLand){ hitLand = true; landPoint = { lat, lon, index: i }; landIndex = i; break; }
    safe.push([lat, lon]);
  }
  return { safePath: safe, hitLand, landPoint, paramsUsed, fullPath: path, landIndex };
}

/* ---------- Wiring UI ---------- */

document.getElementById('sample-btn').addEventListener('click', ()=>{
  document.getElementById('article-input').value =
`Breaking: Tanker 'MV Mariner's Hope' suffered hull breach 5 nm SE of Havelock Island. Heavy crude leaking. Approx coords: 12.0215, 92.9803. Secondary sheen near 11.5300, 92.6200.`;
  setStatus('Sample inserted.');
});

document.getElementById('analyze-btn').addEventListener('click', async ()=>{
  setStatus('Parsing input...');
  clearOverlays();
  const article = document.getElementById('article-input').value.trim();
  if(!article){ setStatus('Paste article text first.', true); return; }

  const windSpeed = Number(document.getElementById('wind-speed').value) || 7.0;
  const windFromDeg = Number(document.getElementById('wind-dir').value) || 225;
  const currentSpeed = Number(document.getElementById('current-speed').value) || 0.5;
  const currentToDeg = Number(document.getElementById('current-dir').value) || 225;
  const windage = Number(document.getElementById('windage').value) || 0.03;
  const diffusion = Number(document.getElementById('diffusion').value) || 2.0;

  // 1) extract coords
  let spills = extractCoordsFromText(article);

  // 2) if none found, fallback to a single default (but warn)
  if(spills.length === 0){
    const bb = REEF_BBOXES.Havelock_Island;
    spills.push({ lat:(bb.lat_min+bb.lat_max)/2, lon:(bb.lon_min+bb.lon_max)/2, source:'default', name:'Havelock Island (default)'});
    setStatus('No coordinates found; using Havelock center as default.', true);
  }

  // Prepare UI aggregates
  const reefSummary = {}; Object.keys(REEF_BBOXES).forEach(k => reefSummary[k] = { willHit:false, etaHours:null, bySpill:-1, distanceKm:null });
  const spillDetails = [];

  // keep math readout cumulative
  const mathLines = [];

  for(let i=0;i<spills.length;i++){
    const s = spills[i];
    const label = s.name || `Spill ${i+1}`;
    const marker = L.marker([s.lat, s.lon], { icon: L.divIcon({ html: '🛢️', className: 'text-3xl' }) }).addTo(map).bindPopup(`<b>${label}</b><br>${s.lat.toFixed(5)}, ${s.lon.toFixed(5)}<br>source:${s.source||'input'}`);
    markers.push(marker);

    setStatus(`Projecting spill ${i+1}...`);
    const modelOptions = { hours:96, dtHours:1, windSpeed, windFromDeg, currentSpeed, currentToDeg, windage, diffusion };

    let result;
    try{ result = await projectStoppingAtLand(s.lat, s.lon, modelOptions); }
    catch(err){ console.error(err); setStatus('Projection error: '+err.message, true); return; }

    const pathToDraw = result.safePath.length ? result.safePath : result.fullPath;
    const colors = ['#f97316','#ef4444','#06b6d4','#a78bfa','#f59e0b','#34d399'];
    const poly = L.polyline(pathToDraw, { color: colors[i%colors.length], weight:3, dashArray:'6,6' }).addTo(map);
    trajectories.push(poly);

    if(result.hitLand && result.landPoint){
      const lp = result.landPoint;
      const lm = L.marker([lp.lat, lp.lon], { icon: L.divIcon({ html: '⛔', className: 'text-2xl' }) }).addTo(map).bindPopup(`<b>Land reached</b><br>Index: ${lp.index}`);
      markers.push(lm);
    }

    const p = result.paramsUsed;
    const driftSpeed = Math.sqrt(p.advU*p.advU + p.advV*p.advV);
    const metersPerHour = driftSpeed * 3600;
    mathLines.push(`Spill ${i+1}: adv u=${p.advU.toFixed(4)} m/s, adv v=${p.advV.toFixed(4)} m/s, speed=${driftSpeed.toFixed(4)} m/s (${metersPerHour.toFixed(0)} m/hr), diffusionσ=${p.diffusionStd.toFixed(1)} m`);

    const reefRes = analyzePathAgainstReefs(pathToDraw, REEF_BBOXES, 1);
    Object.entries(reefRes).forEach(([rk, r])=>{
      if(reefSummary[rk].distanceKm === null || (r.distanceKm !== null && r.distanceKm < reefSummary[rk].distanceKm)) reefSummary[rk].distanceKm = r.distanceKm;
      if(r.willHit){
        if(!reefSummary[rk].willHit || (r.etaHours !== null && (reefSummary[rk].etaHours === null || r.etaHours < reefSummary[rk].etaHours))){
          reefSummary[rk].willHit = true;
          reefSummary[rk].etaHours = r.etaHours;
          reefSummary[rk].bySpill = i;
        }
      }
    });

    const hits = Object.entries(reefRes).filter(([_,rr])=>rr.willHit).map(([rk,rr])=>`${rk.replace(/_/g,' ')} (ETA ${rr.etaHours}h)`);
    spillDetails.push({ index:i, label, lat:s.lat, lon:s.lon, source:s.source||'input', hits: hits.length?hits:['none within projection window'] });
  }

  // update math readout
  document.getElementById('math-readout').textContent = mathLines.join('\n');

  // update reef summary
  const reefDiv = document.getElementById('reef-summary');
  let html = '<table><thead><tr><th>Reef</th><th>Threat</th><th>ETA (h)</th><th>Dist (km)</th><th>By</th></tr></thead><tbody>';
  Object.entries(reefSummary).forEach(([rk,v])=>{
    html += `<tr><td>${rk.replace(/_/g,' ')}</td><td>${v.willHit?'<span style="color:#fca5a5">HIGH</span>':'<span style="color:#9fe6c8">LOW</span>'}</td><td>${v.etaHours!==null?v.etaHours:'N/A'}</td><td>${v.distanceKm!==null?v.distanceKm.toFixed(2):'N/A'}</td><td>${v.bySpill>=0?('Spill '+(v.bySpill+1)):'-'}</td></tr>`;
  });
  html += '</tbody></table>';
  reefDiv.innerHTML = html;

  // spill summary
  const spillDiv = document.getElementById('spill-summary');
  let sh = '<table><thead><tr><th>#</th><th>Location</th><th>Source</th><th>Hits</th></tr></thead><tbody>';
  spillDetails.forEach(sd=>{ sh += `<tr><td>${sd.index+1}</td><td>${sd.label} (${sd.lat.toFixed(4)}, ${sd.lon.toFixed(4)})</td><td>${sd.source}</td><td>${sd.hits.join(', ')}</td></tr>`; });
  sh += '</tbody></table>';
  spillDiv.innerHTML = sh;

  // fit bounds
  try{ const group = new L.featureGroup(markers.concat(Array.from(reefLayer.getLayers()))); map.fitBounds(group.getBounds().pad(0.25)); } catch(e){}
  setStatus('Projection complete — reef table updated.');
});
</script>
</body>
</html>