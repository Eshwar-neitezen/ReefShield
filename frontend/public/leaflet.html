<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Oil Spill Trajectory</title>

<!-- Tailwind (UI) -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- Turf (for point-in-polygon land tests) -->
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<style>
  body{background:#071225;color:#e6eef8;font-family:Inter,system-ui,Arial;margin:0;padding:18px}
  .card{background:#071426;border:1px solid #122033;border-radius:10px;padding:14px}
  .small{font-size:13px;color:#9fb0d6}
  .leaflet-container{height:60vh;border-radius:8px;border:1px solid #0e2533}
  .field-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .input-row{display:flex;flex-direction:column}
  .muted{color:#9fb0d6;font-size:12px}
  pre.math{background:#041427;padding:10px;border-radius:6px;color:#cfe8ff;overflow:auto}
</style>
</head>
<body>
  <div class="max-w-7xl mx-auto space-y-6">
    <header class="text-center">
      <h1 class="text-2xl font-bold">üõ¢Ô∏è Oil Spill Trajectory</h1>
      <p class="small mt-1">Model: drift = current + windage¬∑wind + diffusion. Stops when trajectory hits land (turf or Nominatim fallback).</p>
    </header>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <!-- Controls -->
      <aside class="card lg:col-span-1 space-y-3">
        <label class="small mt-2"><strong>Enter the Coordinates( Latitude and Longitude )</code> pairs</strong></label>
        <textarea id="article-input" rows="7" class="w-full p-2 rounded bg-[#041426] border border-[#123040]" placeholder="Paste coordinates like 12.02123, 92.98012 here"></textarea>

        <label class="small mt-2"><strong>Environmental inputs (labeled)</strong></label>
        <div class="field-grid">
          <div class="input-row">
            <label><strong>Wind speed</strong> <span class="muted">(m/s)</span></label>
            <input id="wind-speed" type="number" step="0.1" value="7.0" class="p-2 rounded bg-[#041426] border border-[#123040]">
            <label class="help">Wind speed (m/s)</label>
          </div>
          <div class="input-row">
            <label><strong>Wind direction</strong> <span class="muted">(¬∞ from - meteorological)</span></label>
            <input id="wind-dir" type="number" step="1" value="225" class="p-2 rounded bg-[#041426] border border-[#123040]">
            <label class="help">Meteorological degrees (wind <em>from</em>).</label>
          </div>
          <div class="input-row">
            <label><strong>Current speed</strong> <span class="muted">(m/s)</span></label>
            <input id="current-speed" type="number" step="0.1" value="0.5" class="p-2 rounded bg-[#041426] border border-[#123040]">
            <label class="help">Surface current magnitude (m/s)</label>
          </div>
          <div class="input-row">
            <label><strong>Current direction</strong> <span class="muted">(¬∞ to - flow direction)</span></label>
            <input id="current-dir" type="number" step="1" value="225" class="p-2 rounded bg-[#041426] border border-[#123040]">
            <label class="help">Direction current is flowing <em>to</em>.</label>
          </div>
          <div class="input-row">
            <label><strong>Windage</strong> <span class="muted">(fraction)</span></label>
            <input id="windage" type="number" step="0.01" value="0.03" class="p-2 rounded bg-[#041426] border border-[#123040]">
            <label class="help">Fraction of wind that pushes surface oil (0.01‚Äì0.06 typical).</label>
          </div>
          <div class="input-row">
            <label><strong>Diffusion</strong> <span class="muted">(m¬≤/s)</span></label>
            <input id="diffusion" type="number" step="0.1" value="2.0" class="p-2 rounded bg-[#041426] border border-[#123040]">
            <label class="help">Horizontal diffusion coefficient (m¬≤/s).</label>
          </div>
        </div>

        <div class="flex gap-2 mt-3">
          <button id="analyze-btn" class="flex-1 py-2 rounded bg-blue-600 hover:bg-blue-700">Analyze & Project</button>
          <button id="sample-btn" class="py-2 px-3 rounded bg-gray-800 border border-gray-700">Sample</button>
        </div>

        <div id="status" class="small mt-2">Status: waiting</div>
        <div class="small mt-2">Tip: If you have a coastline GeoJSON for your region, set <code>COASTLINE_GEOJSON</code> in the script for fast land checks.</div>
      </aside>

      <!-- Map + outputs -->
      <main class="card lg:col-span-2">
        <div id="map" class="leaflet-container"></div>

        <div class="mt-3 grid grid-cols-1 md:grid-cols-3 gap-3">
          <div class="p-2">
            <h3 class="font-semibold">Math readout</h3>
            <pre id="math-readout" class="math">No run yet.</pre>
          </div>
          <div class="p-2">
            <h3 class="font-semibold">Reef Hit Summary</h3>
            <div id="reef-summary" class="small mt-2">No run yet.</div>
          </div>
          <div class="p-2">
            <h3 class="font-semibold">Spill Details</h3>
            <div id="spill-summary" class="small mt-2">No run yet.</div>
          </div>
        </div>
      </main>
    </div>
  </div>

<script>
/* ============================
   Optional: paste coastline GeoJSON here for accurate land checks.
   Example:
   const COASTLINE_GEOJSON = { "type":"FeatureCollection", "features":[ ... ] };
   If undefined, the app uses Nominatim reverse-geocode fallback (slower + rate-limited).
*/
 // const COASTLINE_GEOJSON = ... ;

/* ---------------- REEF BBOXES ---------------- */
const REEF_BBOXES = {
  Havelock_Island: { lat_min:11.90, lat_max:12.05, lon_min:92.90, lon_max:93.05 },
  MG_Marine_NP:    { lat_min:11.50, lat_max:11.65, lon_min:92.55, lon_max:92.70 },
  Jolly_Buoy:      { lat_min:11.47, lat_max:11.52, lon_min:92.58, lon_max:92.64 },
  Neil_Island:     { lat_min:11.77, lat_max:11.88, lon_min:92.99, lon_max:93.10 }
};

/* ---------------- MAP ---------------- */
const map = L.map('map').setView([11.95, 92.95], 8);
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',{maxZoom:19}).addTo(map);
const reefLayer = L.layerGroup().addTo(map);
Object.entries(REEF_BBOXES).forEach(([k,bb])=>{
  const rect = L.rectangle([[bb.lat_min,bb.lon_min],[bb.lat_max,bb.lon_max]], { color:'#0ea5a4', weight:1, fillOpacity:0.06 }).addTo(reefLayer);
  rect.bindPopup(`<strong>${k.replace(/_/g,' ')}</strong>`);
});

/* overlays state */
let markers = [], trajectories = [];

/* ---------- Utilities: math & model ---------- */
function setStatus(msg, isErr=false){ const el=document.getElementById('status'); el.textContent='Status: '+msg; el.style.color = isErr ? '#fca5a5' : '#c7d2fe'; }
function clearOverlays(){ markers.forEach(m=>map.removeLayer(m)); markers=[]; trajectories.forEach(t=>map.removeLayer(t)); trajectories=[]; }

/* haversine (meters) */
function haversine_m(lat1, lon1, lat2, lon2){
  const R=6371000.0, toRad=Math.PI/180;
  const p1=lat1*toRad, p2=lat2*toRad; const dp=(lat2-lat1)*toRad, dl=(lon2-lon1)*toRad;
  const a=Math.sin(dp/2)**2 + Math.cos(p1)*Math.cos(p2)*Math.sin(dl/2)**2;
  return 2*R*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

/* wind-from (meteorological) -> wind-to uv components (east,north) */
function windFromToUV(speed_mps, windFromDeg){
  const windToDeg = (windFromDeg + 180) % 360;
  const th = windToDeg * Math.PI / 180;
  return { u: speed_mps * Math.sin(th), v: speed_mps * Math.cos(th) };
}

/* current 'to' deg -> uv */
function dirToUV(speed_mps, dirToDeg){
  const th = dirToDeg * Math.PI / 180;
  return { u: speed_mps * Math.sin(th), v: speed_mps * Math.cos(th) };
}

/* Normal(0,1) */
function randn(){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v); }

/* Euler‚ÄìMaruyama projection (meters -> degrees conversion inside) */
function projectDriftAdvanced(lat0, lon0, opts={}){
  const hours = opts.hours ?? 96;
  const dtHours = opts.dtHours ?? 1;
  const dtSec = dtHours * 3600;
  const steps = Math.max(1, Math.round(hours / dtHours));

  // MAPPED FROM UI FIELDS
  const windSpeed = opts.windSpeed ?? 7.0;         // UI: Wind speed (m/s)
  const windFromDeg = opts.windFromDeg ?? 225;    // UI: Wind direction FROM (¬∞)
  const currentSpeed = opts.currentSpeed ?? 0.4;  // UI: Current speed (m/s)
  const currentToDeg = opts.currentToDeg ?? 225;  // UI: Current direction TO (¬∞)
  const windage = opts.windage ?? 0.03;           // UI: Windage (fraction)
  const diffusion = opts.diffusion ?? 2.0;        // UI: Diffusion (m^2/s)
  // -----------------------------------------------

  // wind and current components (m/s)
  const windUV = windFromToUV(windSpeed, windFromDeg);
  const curUV  = dirToUV(currentSpeed, currentToDeg);
  // advective drift (m/s) = current + windage * wind
  const advU = curUV.u + windage * windUV.u; // east m/s
  const advV = curUV.v + windage * windUV.v; // north m/s

  const latPerMeter = 1.0 / 111320.0;
  const diffusionStd = Math.sqrt(2.0 * Math.max(0, diffusion) * dtSec);

  const path = [[lat0, lon0]];
  let lat = lat0, lon = lon0;

  for (let s = 0; s < steps; s++){
    const dx = advU * dtSec;
    const dy = advV * dtSec;
    const rx = randn() * diffusionStd;
    const ry = randn() * diffusionStd;
    const totalDx = dx + rx;
    const totalDy = dy + ry;
    const lonPerMeter = 1.0 / (111320.0 * Math.cos(lat * Math.PI / 180));
    lat += totalDy * latPerMeter;
    lon += totalDx * lonPerMeter;
    path.push([lat, lon]);
  }

  return {
    path,
    paramsUsed: {
      hours, dtHours, windSpeed, windFromDeg, currentSpeed, currentToDeg, windage, diffusion, advU, advV, diffusionStd
    }
  };
}

/* ---------------- Land detection ----------------
   1) If COASTLINE_GEOJSON (FeatureCollection) is defined, use turf.booleanPointInPolygon.
   2) Otherwise, fallback to Nominatim reverse geocode (rate-limited, slow).
*/
async function isPointOnLandReverseGeocode(lat, lon){
  try{
    const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&zoom=8`;
    const r = await fetch(url, { headers: { 'User-Agent': 'OilSpillModel/1.0' }});
    if(!r.ok) return null;
    const j = await r.json();
    const dn = (j.display_name || '').toLowerCase();
    const category = (j.category || '').toLowerCase();
    const type = (j.type || '').toLowerCase();
    // heuristics
    if(dn.includes('sea') || dn.includes('ocean') || category === 'water' || type === 'water' || type === 'bay' || type === 'sea') return false;
    if(j.address && Object.keys(j.address).length > 0) return true;
    return null;
  }catch(err){
    console.warn('Reverse geocode error', err);
    return null;
  }
}

async function isPointOnLand(lat, lon){
  if(typeof COASTLINE_GEOJSON !== 'undefined' && COASTLINE_GEOJSON && COASTLINE_GEOJSON.type === 'FeatureCollection'){
    try{
      const pt = turf.point([lon, lat]);
      // booleanPointInPolygon accepts Feature and FeatureCollection; true => point inside polygon (land)
      return turf.booleanPointInPolygon(pt, COASTLINE_GEOJSON);
    }catch(err){ console.warn('turf error', err); }
  }
  // fallback
  const rc = await isPointOnLandReverseGeocode(lat, lon);
  if(rc === true || rc === false) return rc;
  // if uncertain, assume water (do not prematurely stop)
  return false;
}

/* Project but stop when land encountered (first land point) */
async function projectStoppingAtLand(lat0, lon0, modelOptions){
  // get raw path
  const { path, paramsUsed } = projectDriftAdvanced(lat0, lon0, modelOptions);
  const safe = [];
  let hitLand = false, landPoint = null, landIndex = -1;
  for(let i=0;i<path.length;i++){
    const [lat, lon] = path[i];
    const onLand = await isPointOnLand(lat, lon);
    if(onLand){
      hitLand = true;
      landPoint = { lat, lon, index:i };
      landIndex = i;
      break; // stop at first land hit
    } else {
      safe.push([lat, lon]);
    }
  }
  return { safePath: safe, hitLand, landPoint, paramsUsed, fullPath: path, landIndex };
}

/* Analyze path vs reef bboxes */
function analyzePathAgainstReefs(pathPoints, reefs, dtHours=1){
  const results = {}; const start = pathPoints[0];
  Object.entries(reefs).forEach(([k,bb])=>results[k] = { willHit:false, etaHours:null, distanceKm:null });
  for(let i=0;i<pathPoints.length;i++){
    const [lat, lon] = pathPoints[i];
    Object.entries(reefs).forEach(([k,bb])=>{
      if(!results[k].willHit){
        if(lat >= bb.lat_min && lat <= bb.lat_max && lon >= bb.lon_min && lon <= bb.lon_max){
          results[k].willHit = true;
          results[k].etaHours = i * dtHours;
        }
      }
    });
  }
  Object.entries(reefs).forEach(([k,bb])=>{
    const centerLat = (bb.lat_min+bb.lat_max)/2, centerLon = (bb.lon_min+bb.lon_max)/2;
    const dkm = haversine_m(start[0], start[1], centerLat, centerLon) / 1000.0;
    results[k].distanceKm = Number(dkm.toFixed(2));
  });
  return results;
}

/* ---------------- Extraction & UI glue ---------------- */
function extractCoordsFromText(text){
  const arr = []; const rg = /(-?\d{1,2}\.\d+)\s*,\s*(-?\d{1,3}\.\d+)/g;
  let m; while((m=rg.exec(text))!==null) arr.push({ lat:Number(m[1]), lon:Number(m[2]), source:'regex' });
  return arr;
}

async function callGeminiForSpills(apiKey, articleText){
  if(!apiKey) return null;
  const system = `You are an expert environmental geocoder. From the input article identify all oil spill incidents mentioned and return a JSON object with key "spills": [{lat, lon, location, oil_type, confidence}]. If no coords, set lat/lon to null. Output only JSON.`;
  const payload = { systemInstruction:{ parts:[{ text: system }] }, contents:[{ parts:[{ text: articleText }] }], generationConfig:{ responseMimeType:'application/json' } };
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${encodeURIComponent(apiKey)}`;
  const resp = await fetch(url, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
  if(!resp.ok){ const b = await resp.text(); throw new Error(`Gemini error ${resp.status}: ${b}`); }
  const js = await resp.json(); const text = js?.candidates?.[0]?.content?.parts?.[0]?.text;
  if(!text) throw new Error('Gemini returned no text');
  try{ return JSON.parse(text); } catch(e){ const m = text.match(/\{[\s\S]*\}/); if(m) return JSON.parse(m[0]); throw new Error('Gemini returned non-JSON'); }
}

/* ---------- Wiring: buttons & main flow ---------- */
document.getElementById('sample-btn').addEventListener('click', ()=>{
  document.getElementById('article-input').value =
`Breaking: Tanker 'MV Mariner's Hope' suffered hull breach 5 nm SE of Havelock Island. Heavy crude leaking. Approx coords: 12.0215, 92.9803. Secondary sheen near 11.5300, 92.6200.`;
  setStatus('Sample inserted.');
});

document.getElementById('analyze-btn').addEventListener('click', async ()=>{
  setStatus('Parsing input...');
  clearOverlays();
  const article = document.getElementById('article-input').value.trim();
  if(!article){ setStatus('Paste article text first.', true); return; }

  // read UI labeled inputs
  const windSpeed = Number(document.getElementById('wind-speed').value) || 7.0;
  const windFromDeg = Number(document.getElementById('wind-dir').value) || 225;
  const currentSpeed = Number(document.getElementById('current-speed').value) || 0.5;
  const currentToDeg = Number(document.getElementById('current-dir').value) || 225;
  const windage = Number(document.getElementById('windage').value) || 0.03;
  const diffusion = Number(document.getElementById('diffusion').value) || 2.0;
  const apiKey = document.getElementById('gemini-key').value.trim();

  // 1) regex coords
  let spills = extractCoordsFromText(article);

  // 2) optional Gemini enrichment
  let geminiOut = null;
  if(apiKey){
    setStatus('Calling Gemini for extraction...');
    try{ geminiOut = await callGeminiForSpills(apiKey, article); setStatus('Gemini returned.'); }
    catch(err){ console.warn(err); setStatus('Gemini failed, using regex only.', true); geminiOut = null; }
  }
  if(geminiOut?.spills && Array.isArray(geminiOut.spills)){
    geminiOut.spills.forEach(gs=>{
      const lat = (gs.lat===null||gs.lat===undefined)?null:Number(gs.lat);
      const lon = (gs.lon===null||gs.lon===undefined)?null:Number(gs.lon);
      if(lat !== null && lon !== null && !Number.isNaN(lat) && !Number.isNaN(lon)){
        spills.push({ lat, lon, source:'gemini', name: gs.location || gs.name || null, oil_type: gs.oil_type || null });
      } else {
        if(!geminiOut._named) geminiOut._named = [];
        geminiOut._named.push(gs);
      }
    });
  }

  // 3) map named gemini locations to reef bbox centers if no coords
  if(spills.length === 0 && geminiOut && Array.isArray(geminiOut._named) && geminiOut._named.length>0){
    setStatus('Mapping named Gemini locations to reef bbox centers...');
    geminiOut._named.forEach(gs=>{
      const name = (gs.location||gs.name||'').toLowerCase();
      let mapped=false;
      for(const rk of Object.keys(REEF_BBOXES)){
        if(name.includes(rk.replace(/_/g,' ').toLowerCase())){
          const bb = REEF_BBOXES[rk];
          spills.push({ lat:(bb.lat_min+bb.lat_max)/2, lon:(bb.lon_min+bb.lon_max)/2, source:'bbox-fallback', name: rk });
          mapped=true; break;
        }
      }
    });
  }

  // 4) final fallback
  if(spills.length === 0){
    const bb = REEF_BBOXES.Havelock_Island;
    spills.push({ lat:(bb.lat_min+bb.lat_max)/2, lon:(bb.lon_min+bb.lon_max)/2, source:'default', name:'Havelock Island (default)'});
    setStatus('No coordinates found; using Havelock center as default.', true);
  }

  // prepare UI aggregates
  const reefSummary = {}; Object.keys(REEF_BBOXES).forEach(k => reefSummary[k] = { willHit:false, etaHours:null, bySpill:-1, distanceKm:null });
  const spillDetails = [];

  // simulate each spill (stopping at land)
  for(let i=0;i<spills.length;i++){
    const s = spills[i];
    const label = s.name || `Spill ${i+1}`;
    const marker = L.marker([s.lat, s.lon], { icon: L.divIcon({ html: 'üõ¢Ô∏è', className: 'text-3xl' }) }).addTo(map).bindPopup(`<b>${label}</b><br>${s.lat.toFixed(5)}, ${s.lon.toFixed(5)}<br>source:${s.source||'input'}`);
    markers.push(marker);

    setStatus(`Projecting spill ${i+1}...`);
    const modelOptions = {
      hours:96, dtHours:1,
      windSpeed, windFromDeg,
      currentSpeed, currentToDeg,
      windage, diffusion,
      oilType: s.oil_type || ''
    };

    // project and stop at land
    let result;
    try{ result = await projectStoppingAtLand(s.lat, s.lon, modelOptions); }
    catch(err){ console.error(err); setStatus('Projection error: '+err.message, true); return; }

    // draw trajectory (safePath)
    const colors = ['#f97316','#ef4444','#06b6d4','#a78bfa','#f59e0b','#34d399'];
    const poly = L.polyline(result.safePath.length ? result.safePath : result.fullPath, { color: colors[i%colors.length], weight:3, dashArray:'6,6' }).addTo(map);
    trajectories.push(poly);

    // If land hit, put a land marker at landPoint
    if(result.hitLand && result.landPoint){
      const lp = result.landPoint;
      const lm = L.marker([lp.lat, lp.lon], { icon: L.divIcon({ html: '‚õî', className: 'text-2xl' }) }).addTo(map).bindPopup(`<b>Land reached</b><br>Index: ${lp.index}`);
      markers.push(lm);
    }

    // math readout for this spill (show advective vector + diffusion sigma)
    const mr = document.getElementById('math-readout');
    const p = result.paramsUsed;
    const driftSpeed = Math.sqrt(p.advU*p.advU + p.advV*p.advV);
    const metersPerHour = driftSpeed * 3600;
    const diffusionStd = p.diffusionStd; // meters per dt (dt=1 hr default)
    mr.textContent = `Spill ${i+1} math:
advective east (u) = ${p.advU.toFixed(4)} m/s
advective north (v) = ${p.advV.toFixed(4)} m/s
drift speed = ${driftSpeed.toFixed(4)} m/s (${metersPerHour.toFixed(1)} m/hr)
diffusion sigma per step = ${diffusionStd.toFixed(1)} m (1œÉ)
model params: windSpeed=${p.windSpeed} m/s (from ${p.windFromDeg}¬∞), currentSpeed=${p.currentSpeed} m/s (to ${p.currentToDeg}¬∞), windage=${p.windage}, diffusion=${p.diffusion}
Note: path stopped at land: ${result.hitLand ? 'YES' : 'NO'}.`;

    // analyze reef hits from the safePath (we could also use fullPath)
    const reefRes = analyzePathAgainstReefs(result.safePath.length? result.safePath : result.fullPath, REEF_BBOXES, 1);
    Object.entries(reefRes).forEach(([rk, r])=>{
      if(reefSummary[rk].distanceKm === null || r.distanceKm < reefSummary[rk].distanceKm) reefSummary[rk].distanceKm = r.distanceKm;
      if(r.willHit){
        if(!reefSummary[rk].willHit || (r.etaHours !== null && (reefSummary[rk].etaHours === null || r.etaHours < reefSummary[rk].etaHours))){
          reefSummary[rk].willHit = true;
          reefSummary[rk].etaHours = r.etaHours;
          reefSummary[rk].bySpill = i;
        }
      }
    });

    const hits = Object.entries(reefRes).filter(([_,rr])=>rr.willHit).map(([rk,rr])=>`${rk.replace(/_/g,' ')} (ETA ${rr.etaHours}h)`);
    spillDetails.push({ index:i, label, lat:s.lat, lon:s.lon, source:s.source||'input', hits: hits.length?hits:['none within projection window'] });
  }

  // UI: reef summary
  const reefDiv = document.getElementById('reef-summary');
  let html = '<table class="w-full text-sm"><thead><tr><th>Reef</th><th>Threat</th><th>ETA (h)</th><th>Dist (km)</th><th>By</th></tr></thead><tbody>';
  Object.entries(reefSummary).forEach(([rk,v])=>{
    html += `<tr><td>${rk.replace(/_/g,' ')}</td><td>${v.willHit?'<span style="color:#fca5a5">HIGH</span>':'<span style="color:#9fe6c8">LOW</span>'}</td><td>${v.etaHours!==null?v.etaHours:'N/A'}</td><td>${v.distanceKm!==null?v.distanceKm.toFixed(2):'N/A'}</td><td>${v.bySpill>=0?('Spill '+(v.bySpill+1)):'-'}</td></tr>`;
  });
  html += '</tbody></table>';
  reefDiv.innerHTML = html;

  // UI: spill summary
  const spillDiv = document.getElementById('spill-summary');
  let sh = '<table class="w-full text-sm"><thead><tr><th>#</th><th>Location</th><th>Source</th><th>Hits</th></tr></thead><tbody>';
  spillDetails.forEach(sd=>{ sh += `<tr><td>${sd.index+1}</td><td>${sd.label}</td><td>${sd.source}</td><td>${sd.hits.join(', ')}</td></tr>`; });
  sh += '</tbody></table>';
  spillDiv.innerHTML = sh;

  // fit bounds
  try{ const group = new L.featureGroup(markers.concat(Array.from(reefLayer.getLayers()))); map.fitBounds(group.getBounds().pad(0.25)); } catch(e){}
  setStatus('Projection complete ‚Äî reef table updated.');
});
</script>
</body>
</html>
